/* The Computer Language Benchmarks Game
   http://benchmarksgame.alioth.debian.org/ 

   contributed by Marek Safar  
   concurrency added by Peperud
   *reset*
*/

using System;
using System.Collections.Generic;
using System.Threading.Tasks;

class BinaryTrees
{
    const int MIN_DEPTH = 4;

    public static void Main(string[] args)
    {
        int n = 0;
        if (args.Length > 0) n = int.Parse(args[0]);

        int maxDepth = n < (MIN_DEPTH + 2) ? MIN_DEPTH + 2 : n;
        int stretchDepth = maxDepth + 1;

        Task<int>[] Tcheck =
        {
                Task.Run(() => TreeNode.bottomUpTree(stretchDepth).itemCheck()),
                Task.Run(() => TreeNode.bottomUpTree(maxDepth).itemCheck())
        };

        string[] results = new string[(maxDepth - MIN_DEPTH) / 2 + 1];

        var depts = new List<Action>(maxDepth);

        for (int d = maxDepth; d >= MIN_DEPTH; d -= 2)
        {
            var depth = d;
            depts.Add(() =>
            {
                int iterations = 1 << (maxDepth - depth + MIN_DEPTH);

                int check = 0;
                for (int i = 1; i <= iterations; i++)
                {
                    Task<int>[] btm =
                    {
                        Task.Run(() => TreeNode.bottomUpTree(depth).itemCheck())
                    };

                    Task.WaitAll(btm);

                    check += btm[0].Result;
                }

                results[(depth - MIN_DEPTH) / 2] = iterations + 
                    "\t trees of depth " + depth + "\t check: " + check;
            });
        }

        Parallel.Invoke(new ParallelOptions { 
            MaxDegreeOfParallelism = Environment.ProcessorCount + 1 }, depts.ToArray());

        Task.WaitAll(Tcheck);

        Console.WriteLine("stretch tree of depth {0}\t check: {1}",
            stretchDepth, Tcheck[0].Result);

        foreach (var result in results)
        {
            Console.WriteLine(result);
        }

        Console.WriteLine("long lived tree of depth {0}\t check: {1}", 
            maxDepth, Tcheck[1].Result);
    }

    struct TreeNode
    {
        sealed class Next
        {
            public TreeNode left, right;
        }

        private Next next;

        TreeNode(int item)
        {
            this.next = null;
        }

        TreeNode(TreeNode left, TreeNode right)
        {
            this.next = new Next();
            this.next.left = left;
            this.next.right = right;
        }

        internal static TreeNode bottomUpTree(int depth)
        {
            if (depth > 0)
            {
                int d;
                d = depth - 1;

                var left = bottomUpTree(d);
                var right = bottomUpTree(d);
                return new TreeNode(left, right);
            }
            else
            {
                return new TreeNode();
            }
        }

        internal int itemCheck()
        {
            if (next == null)
            {
                return 1;
            }
            return 1 + next.left.itemCheck() + next.right.itemCheck();
        }
    }
}
